<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Schemaless Postgres - tristin forbus</title>
  <meta property="og:title" content="Schemaless Postgres - tristin forbus" />
  <meta name="twitter:title" content="Schemaless Postgres - tristin forbus" />
  <meta name="description" content="I stumbled across a link on HackerNews that Reddit&rsquo;s database has two tables. Inside was a blog post from 2012 that referenced a presentation by Steve Huffman from 2010. The interesting thing is how Reddit effectively had no schema for their data, even though they were (at least at the time) using Postgres for storage. The gist is there are two tables. One table has the metadata about every thing that Reddit has: users, subreddits, comments, etc.">
  <meta property="og:description" content="I stumbled across a link on HackerNews that Reddit&rsquo;s database has two tables. Inside was a blog post from 2012 that referenced a presentation by Steve Huffman from 2010. The interesting thing is how Reddit effectively had no schema for their data, even though they were (at least at the time) using Postgres for storage. The gist is there are two tables. One table has the metadata about every thing that Reddit has: users, subreddits, comments, etc.">
  <meta name="twitter:description" content="I stumbled across a link on HackerNews that Reddit&rsquo;s database has two tables. Inside was a blog post from 2012 that referenced a presentation by Steve Huffman from 2010. The interesting thing is â€¦">
  <meta name="author" content=""/>
  <meta property="og:site_name" content="tristin forbus" />
  <meta property="og:url" content="http://tristinforbus.com/posts/schemaless-postgres/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.120.4">
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/style-dark.css" media="all and (prefers-color-scheme: dark)" />

  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">tristin forbus</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Schemaless Postgres</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>December 3, 2023</time></li>
        <li class="article-meta-tags">
          <a href="/tags/database/">
            <i class="fas fa-tag"></i>
            database
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/nosql/">
            <i class="fas fa-tag"></i>
            nosql
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/postgres/">
            <i class="fas fa-tag"></i>
            postgres
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#schemaless-users">Schemaless users</a></li>
    <li><a href="#traditional-user-model">Traditional user model</a></li>
    <li><a href="#measuring-performance">Measuring performance</a></li>
    <li><a href="#the-experiment">The experiment</a></li>
    <li><a href="#results">Results</a></li>
    <li><a href="#revisiting-schemaless">Revisiting schemaless</a></li>
    <li><a href="#conclusions">Conclusions</a></li>
  </ul>
</nav>
</aside>
      <p>I stumbled across a link on HackerNews that <a href="https://news.ycombinator.com/item?id=32407873">Reddit&rsquo;s database has two tables</a>.
Inside was a blog post from 2012 that referenced a presentation by Steve Huffman from 2010. The interesting thing is how Reddit effectively had no schema for their data, even though they were (at least at the time) using Postgres for storage. The gist is there are two tables. One table has the metadata about every <em>thing</em> that Reddit has: users, subreddits, comments, etc.  The second table contains all the data about a <em>thing</em>, but each attribute of that data is spread across a new row. If you read the HackerNews link, you&rsquo;ll find that the pros and cons of this approach are a religious debate. After really only using Key-Value and Document databases, I couldn&rsquo;t shake the desire to try this out.</p>
<p>And just to clarify, I have so little experience with Postgres we can round it down to zero.</p>
<h2 id="schemaless-users">Schemaless users</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Using INT as an identifier here so the content is easier to follow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="n">users_noschema</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">attr</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">attr_data</span><span class="w"> </span><span class="n">JSONB</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">unique_id_attr</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span></span></span></code></pre></div>
<p>With this psql, we create a table with only 3 columns, with id+attr making up a primary key. We&rsquo;ve successfully created a key-value store. The <em>attr_data</em> column can store data of any kind, and we can cast it to whatever we want later. If we want to put something in our table, we can execute a query to insert arbitrary data for arbitrary attributes on a user.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Creating a new user with one attribute email
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users_noschema</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">attr_data</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;email&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#34;bob@example.com&#34;&#39;</span><span class="p">);</span></span></span></code></pre></div>
<p>But writing a user like this, one attribute at a time seems like a drag. If the user was just one row, we could perform one write and be done. To write multiple values at once, we just need to extend the first insert statement a bit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Create a user with multiple attributes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users_noschema</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">attr_data</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;email&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#34;alice@example.com&#34;&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;favoriteNumber&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;42&#39;</span><span class="p">);</span></span></span></code></pre></div>
<p>So now we&rsquo;ve inserted an Alice into our database and given her two properties: email, and favorite nummber. One thing we can see from here is that if our user has <em>N</em> properties at creation time, then we&rsquo;ll perform <em>N</em> writes to the database, and likewise if we want to read an entire user, we&rsquo;ll read <em>N</em> rows.</p>
<p>To read Alice and all her properties, we could do a simple query selecting on her ID.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users_noschema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span></span></span></code></pre></div>
<p>This will return a result of <em>N</em> rows. But because we&rsquo;ve got a JSONB column, we could return 1 row!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">jsonb_object_agg</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">attr_data</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">user_data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">users_noschema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span></span></span></code></pre></div>
<p>And this will return a result with 2 columns: id, and user_data. The user_data is a JSONB object where our attributes are keys, and the values are the corresponding attr_data entries. It would look something like the blob below.</p>
<table>
<thead>
<tr>
<th>id (integer)</th>
<th>user_data (jsonb)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span><span class="nt">&#34;emailAddress&#34;</span><span class="p">:</span> <span class="s2">&#34;alice@example.com&#34;</span><span class="p">,</span> <span class="nt">&#34;favoriteNumber&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}</span></span></span></code></pre></div></td>
</tr>
</tbody>
</table>
<p>Pretty cool! We can extend this pattern to query for a page of users, all users, or a projection of a subset of user properties. To get a projection that only has the user email addresses, we can use a query like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">jsonb_object_agg</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">attr_data</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;emailAddress&#39;</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">user_data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">users_noschema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span></span></span></code></pre></div>
<p>Updating a user can be done one attribute at a time, or with multiple updates as we did with insert. If we need to make updates to Alice, it&rsquo;s easy enough.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">UPDATE</span><span class="w"> </span><span class="n">users_noschema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">attr_data</span><span class="o">=</span><span class="s1">&#39;7&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">attr</span><span class="o">=</span><span class="s1">&#39;favoriteNumber&#39;</span><span class="p">;</span></span></span></code></pre></div>
<p>If we need to make multiple updates to Alice, we can use CASE.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">UPDATE</span><span class="w"> </span><span class="n">users_noschema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">attr_data</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CASE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">WHEN</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;emailAddress&#39;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;&#34;alice.goth@example.com&#34;&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">WHEN</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;favoriteNumber&#39;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;666&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">ELSE</span><span class="w"> </span><span class="n">attr_data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">END</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span></span></span></code></pre></div>
<p>Deleting a user is straightforward.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users_noschema</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span></span></span></code></pre></div></p>
<p>So we can perform the bread and butter CRUD operations on our data. That&rsquo;s a good start for a web application. Postgres allows you to reach into jsonb columns so we can even filter on items of interest. But is this key-value version of a table any good? We&rsquo;ve gained a lot flexibility with this key-value approach, and we could even put different types of <em>things</em> in this single table. That could potentially reduce some operations we need to worry about. It might simplify some maintenance tasks. Then again, it might not. All of this stuff is really <em>it depends</em>, but one thing we can quantify is the performance of this approach vs a traditional schema model.</p>
<h2 id="traditional-user-model">Traditional user model</h2>
<p>We&rsquo;ve created a schemaless user model where we really just have 3 fields: ID, email address, and favorite number. We can model that in a way you might normally do in a relational database.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Using INT as an identifier here so the content is easier to follow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="n">users_schema</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">email_address</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">favorite_number</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">unique_id</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span></span></span></code></pre></div>
<p>I&rsquo;m going to breeze by CRUD operations here, because it will look sane to anyone who&rsquo;s written a SQL query before.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Create Alice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users_schema</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">favorite_number</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;alice@example.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Retrieve Alice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users_schema</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Update Alice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">users_schema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">email_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;alice.goth@example.com&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">favorite_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;666&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;1&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Delete Alice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users_schema</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span></span></span></code></pre></div>
<h2 id="measuring-performance">Measuring performance</h2>
<p>We can use the EXPLAIN ANALYZE tool to get some details about our queries.
This tool accepts a statement, executes it, and then provides a query plan. My understanding of the query plan is Postgres is figuring out the best way to execute your query and get your data back. From the output of this, we&rsquo;re looking for the shortest planning and execution times, as well as cost. From the <a href="">Postgres docs on EXPLAIN</a>:</p>
<blockquote>
<p>The most critical part of the display is the estimated statement execution cost, which is the planner&rsquo;s guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters&hellip;</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Create Alice (explain)
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users_schema</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">favorite_number</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;alice@example.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span></span></span></code></pre></div>
<p>Here&rsquo;s an output I got from running this command on a local Postgres instance.</p>
<pre><code> Insert on users_schema  (cost=0.00..0.01 rows=0 width=0) (actual time=0.173..0.175 rows=0 loops=1)
   -&gt;  Result  (cost=0.00..0.01 rows=1 width=40) (actual time=0.003..0.005 rows=1 loops=1)
 Planning Time: 0.037 ms
 Execution Time: 0.205 ms
(4 rows)
</code></pre>
<p>We can compare this to inserting with our schemaless design.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Create a user with multiple attributes
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users_noschema</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">attr_data</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;email&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#34;alice@example.com&#34;&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;favoriteNumber&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;42&#39;</span><span class="p">);</span></span></span></code></pre></div>
<pre><code> Insert on users_noschema  (cost=0.00..0.03 rows=0 width=0) (actual time=0.121..0.121 rows=0 loops=1)
   -&gt;  Values Scan on &quot;*VALUES*&quot;  (cost=0.00..0.03 rows=2 width=68) (actual time=0.004..0.006 rows=2 loops=1)
 Planning Time: 0.047 ms
 Execution Time: 0.140 ms
(4 rows)
</code></pre>
<p>This is just an n=1 result on a toy table, but we can already see a difference in the cost of these queries.</p>
<h2 id="the-experiment">The experiment</h2>
<p>Reddit scaled to <a href="http://highscalability.com/blog/2010/5/17/7-lessons-learned-while-building-reddit-to-270-million-page.html">7.5 million users and 270 million page views</a> per month using a schemaless design.
We want to measure how a schemaless design performs against a schema design for a database of non-trivial size. We&rsquo;ll seed the database with users, record how long it takes to write each user, and then run the queries for retrieve, update and list some number of times to gain confidence in our numbers.</p>
<p>The pseudocode for what&rsquo;s happening is as follows:</p>
<pre><code>// seed database with one million users
for i := 0; i &lt; 1_000_000; i++ {
    create a user
    record cost, randomly up until 1000 samples recorded.
}

for i := 0; i &lt; 1000; i++ {
    get a user
    record cost

    update a user
    record cost

    get multiple users (list)
    record cost
}
</code></pre>
<p>The data from the EXPLAIN calls will be sent to another table called performance. We can then query this table to compare results from the schemaless design and schema design. I&rsquo;m only going to be using total cost, but it is nice to store some additional data for some further investigation. The <em>operation</em> in this schema refers to create, retrieve, list, or update, not the operation Postgres is doing under the hood.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="n">performance</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">SERIAL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">has_schema</span><span class="w"> </span><span class="nb">BOOLEAN</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">operation</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">startup_cost</span><span class="w"> </span><span class="nb">FLOAT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">total_cost</span><span class="w"> </span><span class="nb">FLOAT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">total_time</span><span class="w"> </span><span class="nb">FLOAT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">execution_time</span><span class="w"> </span><span class="nb">FLOAT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span></span></span></code></pre></div>
<h2 id="results">Results</h2>
<p>We can quickly query some basic information about each operation and method with a query like the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">VARIANCE</span><span class="p">(</span><span class="n">total_cost</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">MIN</span><span class="p">(</span><span class="n">total_cost</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">MAX</span><span class="p">(</span><span class="n">total_cost</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">AVG</span><span class="p">(</span><span class="n">total_cost</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">performance</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="k">operation</span><span class="o">=</span><span class="s1">&#39;{create|retrieve|update|list}&#39;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">has_schema</span><span class="o">=</span><span class="err">{</span><span class="k">true</span><span class="o">|</span><span class="k">false</span><span class="err">}</span></span></span></code></pre></div>
<p>The results are recorded below.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Operation</th>
<th style="text-align:right">Var</th>
<th style="text-align:right">Min</th>
<th style="text-align:right">Max</th>
<th style="text-align:right">Avg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Schemaless create</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0.040</td>
<td style="text-align:right">0.040</td>
<td style="text-align:right">0.040</td>
</tr>
<tr>
<td style="text-align:left">Schemaless retrieve</td>
<td style="text-align:right">0</td>
<td style="text-align:right">19.080</td>
<td style="text-align:right">19.080</td>
<td style="text-align:right">19.080</td>
</tr>
<tr>
<td style="text-align:left">Schemaless update</td>
<td style="text-align:right">0</td>
<td style="text-align:right">19.110</td>
<td style="text-align:right">19.110</td>
<td style="text-align:right">19.110</td>
</tr>
<tr>
<td style="text-align:left">Schemaless list</td>
<td style="text-align:right">437152773.482</td>
<td style="text-align:right">72.820</td>
<td style="text-align:right">72392.211</td>
<td style="text-align:right">36232.445</td>
</tr>
<tr>
<td style="text-align:left">Schema create</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0.010</td>
<td style="text-align:right">0.010</td>
<td style="text-align:right">0.010</td>
</tr>
<tr>
<td style="text-align:left">Schema retrieve</td>
<td style="text-align:right">0</td>
<td style="text-align:right">8.440</td>
<td style="text-align:right">8.440</td>
<td style="text-align:right">8.440</td>
</tr>
<tr>
<td style="text-align:left">Schema update</td>
<td style="text-align:right">0</td>
<td style="text-align:right">8.440</td>
<td style="text-align:right">8.440</td>
<td style="text-align:right">8.440</td>
</tr>
<tr>
<td style="text-align:left">Schema list</td>
<td style="text-align:right">66965118.695</td>
<td style="text-align:right">28.760</td>
<td style="text-align:right">28333.770</td>
<td style="text-align:right">14181.266</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ul>
<li>There&rsquo;s so much variance with the <em>list</em> operations because with each check, the offset is higher.</li>
<li>I used 3 attributes, rather than 2 in the preceding discussion. Adding 1 more attribute increased the cost of schemaless create by .01, so we can assume how new attributes would cost cost to scale.</li>
<li>With the exception of list, it looks like there&rsquo;s no need to run these operations multiple times. That makes sense, since we&rsquo;re doing everything based on a primary key.</li>
</ul>
<p>Overall we can observe that the schemaless approach is more costly than the schema version. It&rsquo;s important to note that JSONB wasn&rsquo;t introduced in Postgres until 2012, 2 years after Huffman&rsquo;s talk. Maybe they used stringy values only in the <em>attr_data</em> column and converted to the types they wanted in the queries. That would certainly give some different results. An obvious thing to consider is what if our key-value structure was just an ID and a JSONB column that contained all the user information. Then we&rsquo;d still have one row per user.</p>
<p>I&rsquo;d like to explore the second question further: what if our schema was just an (id, jsonb) tuple? Surely the overall costs compared to schemaless would be less.</p>
<h2 id="revisiting-schemaless">Revisiting schemaless</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="n">users_noschema2</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">kvs</span><span class="w"> </span><span class="n">JSONB</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">ns_unique_id</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Creating a user
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users_noschema2</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">kvs</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;{&#34;email&#34;: &#34;alice@example.com&#34;, &#34;favoriteNumber&#34;: 42 }&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Total Cost 0.01
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Retrieving a user
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users_noschema2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Total Cost 8.17
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Retrieving a projection of a user
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">kvs</span><span class="o">-&gt;&gt;</span><span class="s1">&#39;email&#39;</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users_noschema2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Total Cost 8.17
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Updating a user
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">users_noschema2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">kvs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;{&#34;email&#34;: &#34;alice.goth@example.com&#34;, &#34;favoriteNumber&#34;: 666}&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Total Cost 8.17
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Updating a particular field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">users_noschema2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">kvs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kvs</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;{&#34;email&#34;: &#34;alice.new@example.com&#34;}&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;1&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Total Cost 8.17</span></span></span></code></pre></div>
<p>These results already look better than the N-rows-per-attribute version earlier, and they&rsquo;re similar enough to the schema version that either one seems reasonable. But so far we haven&rsquo;t done any queries around filtering the users on some attributes. We&rsquo;ve got to seed another schemaless table with one million users first.</p>
<p>Let&rsquo;s filter on the favorite numbers. The datasets don&rsquo;t match up 1-1, but we should be able to figure out a cost comparison.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Schema
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="p">,</span><span class="w"> </span><span class="n">FORMAT</span><span class="w"> </span><span class="n">JSON</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">tmp_schema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">favorite_number</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span></span></span></code></pre></div>
<p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Plan&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Node Type&#34;</span><span class="p">:</span> <span class="s2">&#34;Seq Scan&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Parallel Aware&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Async Capable&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Relation Name&#34;</span><span class="p">:</span> <span class="s2">&#34;tmp_schema&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Alias&#34;</span><span class="p">:</span> <span class="s2">&#34;tmp_schema&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Startup Cost&#34;</span><span class="p">:</span> <span class="mf">0.00</span><span class="p">,</span>
</span></span><span class="line hl"><span class="cl">      <span class="nt">&#34;Total Cost&#34;</span><span class="p">:</span> <span class="mf">87811.54</span><span class="p">,</span>
</span></span><span class="line hl"><span class="cl">      <span class="nt">&#34;Plan Rows&#34;</span><span class="p">:</span> <span class="mi">459466</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Plan Width&#34;</span><span class="p">:</span> <span class="mi">530</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Actual Startup Time&#34;</span><span class="p">:</span> <span class="mf">0.032</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Actual Total Time&#34;</span><span class="p">:</span> <span class="mf">607.816</span><span class="p">,</span>
</span></span><span class="line hl"><span class="cl">      <span class="nt">&#34;Actual Rows&#34;</span><span class="p">:</span> <span class="mi">498536</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Actual Loops&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Filter&#34;</span><span class="p">:</span> <span class="s2">&#34;(favorite_number &gt; 500)&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Rows Removed by Filter&#34;</span><span class="p">:</span> <span class="mi">501464</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Planning Time&#34;</span><span class="p">:</span> <span class="mf">0.149</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Triggers&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Execution Time&#34;</span><span class="p">:</span> <span class="mf">648.390</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span></span></span></code></pre></div>
I&rsquo;ve highlighted the data that seems pertinent here. For the schema table, the difference in the planned rows and actual rows is 39,070.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Schemaless, v2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="p">,</span><span class="w"> </span><span class="n">FORMAT</span><span class="w"> </span><span class="n">JSON</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">tmp_noschema2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">kvs</span><span class="o">-&gt;</span><span class="s1">&#39;favoriteNumber&#39;</span><span class="p">)::</span><span class="nb">int</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span></span></span></code></pre></div>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Plan&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Node Type&#34;</span><span class="p">:</span> <span class="s2">&#34;Seq Scan&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Parallel Aware&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Async Capable&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Relation Name&#34;</span><span class="p">:</span> <span class="s2">&#34;tmp_noschema2&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Alias&#34;</span><span class="p">:</span> <span class="s2">&#34;tmp_noschema2&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Startup Cost&#34;</span><span class="p">:</span> <span class="mf">0.00</span><span class="p">,</span>
</span></span><span class="line hl"><span class="cl">      <span class="nt">&#34;Total Cost&#34;</span><span class="p">:</span> <span class="mf">94423.70</span><span class="p">,</span>
</span></span><span class="line hl"><span class="cl">      <span class="nt">&#34;Plan Rows&#34;</span><span class="p">:</span> <span class="mi">333328</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Plan Width&#34;</span><span class="p">:</span> <span class="mi">599</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Actual Startup Time&#34;</span><span class="p">:</span> <span class="mf">0.039</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Actual Total Time&#34;</span><span class="p">:</span> <span class="mf">921.486</span><span class="p">,</span>
</span></span><span class="line hl"><span class="cl">      <span class="nt">&#34;Actual Rows&#34;</span><span class="p">:</span> <span class="mi">499316</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Actual Loops&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Filter&#34;</span><span class="p">:</span> <span class="s2">&#34;(((kvs -&gt; &#39;favoriteNumber&#39;::text))::integer &gt; 500)&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Rows Removed by Filter&#34;</span><span class="p">:</span> <span class="mi">500684</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Planning Time&#34;</span><span class="p">:</span> <span class="mf">0.069</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Triggers&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Execution Time&#34;</span><span class="p">:</span> <span class="mf">974.670</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span></span></span></code></pre></div>
<p>Here it looks like storing the data in JSONB affected the query planner. The difference in actual and planned rows is 165,988. Much worse. If we normalize (total cost / actual rows) for each query, the schema version comes in at .176cost/row and the schemaless comes in at .189cost/row. Not much difference in cost, but the planner seems to be worse. Again, my experience with Postgres is effectively 0, but it seems like JSONB columns may perform worse because Postgres can&rsquo;t choose the right plan for the data. I found <a href="https://www.heap.io/blog/when-to-avoid-jsonb-in-a-postgresql-schema">this link</a> on when to avoid using JSONB which explains the planner a little more. To summarize, Postgres can&rsquo;t keep statistics about the data inside of a JSONB column. The query planner uses those statistics to help it estimate which plan will be the best. In that link, the author was also using JOINs on that blob data, which seemed to have a terrible performance hit.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Coming from a background of NoSQL and Key-Value databases, I like that Postgres allows arbitrary data in a column. I think for moving fast initially, being able to play fast and loose with your schema is important. When developing an app, and even once you&rsquo;re getting customers, you&rsquo;re still discovering the shape of your data. Having the flexibility to just add data or ignore data without making database migrations is nice. It&rsquo;s probably a good choice if you don&rsquo;t plan on doing any joins or reporting, just like in a normal key-value datastore, but I haven&rsquo;t done this in production yet. I&rsquo;ve made it this far in life with just DynamoDB, so I am biased.</p>
<p>One cool thing about Postgres is the ability to add a generated column. If you&rsquo;ve decided to go schemaless, you can later generate a column from a field in your JSONB blob and treat it like any other column.</p>

    </article>

    


    <ul class="pager article-pager">
      <li class="pager-newer pager-noitem">&lt; Newer</li>
      <li class="pager-older pager-noitem">Older &gt;</li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright"></div>
  <ul class="site-footer-items">
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>


</body>
</html>
